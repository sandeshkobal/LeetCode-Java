https://leetcode.com/problems/word-search-ii/
Input: 
words = ["oath","pea","eat","rain"] and board =
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
Output: ["eat","oath"]

class Solution {
    // run time  N*4^maxWordLength
    // beacse we creare 4 branches each step and depth is wordLength * N words 
    public List<String> findWords(char[][] board, String[] words) {
        Map<String, Integer> map = new HashMap<>();  // map is used to avoid duplicate
        for (String word: words){
            if (!map.containsKey(word) && findWord(board, word)) {
                map.put(word, 1);
            }
        }
        return new ArrayList<String>(map.keySet());
    }
    
    private boolean findWord(char[][] board, String word) {
        for (int i = 0 ; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (dfs(board, word, 0, i, j)) return true; 
            }
        }
        return false;
    }
    
    private boolean dfs(char[][] board, String word, int cur, int i, int j) {
        if (cur == word.length()) return true;
        if (i < 0 ||  i >= board.length ||  j < 0 ||  j >= board[0].length) return false;
        if (word.charAt(cur) != board[i][j]) return false;
        board[i][j] = '#';
        boolean res = dfs(board, word, cur+1, i-1, j) ||
                        dfs(board, word, cur+1, i+1, j) ||
                        dfs(board, word, cur+1, i, j-1) || 
                        dfs(board, word, cur+1, i, j+1);
        board[i][j] = word.charAt(cur);
        return res;
    }
}
