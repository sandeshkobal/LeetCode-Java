Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

Example 1:
Input: n = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.

Example 2:
Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.

class Solution {
    // This is exactly same as coin change problem. 
    // n*s where s is numbers of perfect squares we gonna consider 
    // This is kindOf/SortOf Subset problem where we say yes there are elements  = SUM/2 ( all positive numebers)
    // In subet we return only true/false if could find the subset to SUM/2 but we don not consider minimum elements to find that SUM. 
    // Here question asks minimum number of elements that leads to SUM and moreover we can use same number multiple times.
    // So we have to keep finding that SUM and then keep track how many elements we used and track minimum. 
    // SO as it looks like subset sum .. it is gonna be m*SUM loop with DP ... but no it is going to be SUM*m .. bcz we can use each number many times. 
    // take new array as dp[0,1,2,.....sumToFind].. obviously we can mark the numbers we have in the nums as true. 
    // but then we have to mark the numbers that are generated by additing each number to nums[i]+nums[j] but if we do that by N^2 then we lost the path to sum..
    // we dont know what numbers to take to lead to SUM 
    // This is NP complete as there no polynimial time soltution and the complexity depends on the SUM number (actual data and not the data set) 
     
    public int numSquares(int SUM) {
        if(SUM<=0) return 0;
        
        // Build all perfect square numbers we need to consider 
        int nums[] = new int[(int) Math.sqrt(SUM) +1];
        for(int i=1;i<=nums.length;i++) {
            nums[i-1] = i*i;
            if(nums[i-1] == SUM)
                return 1;
        }
        
        int []solDP= new int[SUM+1];
        solDP[0] = 0;
        for(int target=1;target<=SUM;target++){  
            int min = Integer.MAX_VALUE; 
            // here we can do MAX_VALUE bcz there is 1 in dataset so will always have solution for each solution
            // if we dont have the sultion for some target M then writing Integer.MAX_VALUE would messup solDP[target-num]+1 and will overflow
            // let that sink in these coments .. see coin change problem 
            for(int num : nums){
                if(target < num)
                    break; // no need process larger numbers 
                min = Math.min(min,solDP[target-num] +1);
            }
            solDP[target] = min;
        }
        return solDP[SUM];
    }
}
