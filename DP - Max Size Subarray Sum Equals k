/* https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/
Input: nums = [1, -1, 5, -2, 3], k = 3
Output: 4 
Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.
O(N)
    // this is a Range SUM problem in constant time.
    // we can build an array so that sum[i] = nums[0]+...+nums[i] for all elements 
    // once you have that you have to find sum[i] - sum[j] = K  while (j<i) also keeping the track of max of (i-j)
    // Now finding that I and J could be N^2 so we use map to find sum[i] - K is there any sum[j] .. this same trick we used for 2SUM problem.
*/
class Solution {
    public int maxSubArrayLen(int[] nums, int k) {
        if (nums == null || nums.length == 0)
            return 0;
        
        int [] sums = new int[nums.length];
        Map<Integer,Integer> map = new HashMap();
        sums[0] = nums[0];

        for(int i=1;i<nums.length;i++){
            sums[i] = sums[i-1] + nums[i];
            // we cant add keys to map here 
            // as this would give the keys of where (j<i) wont hold the true 
            // so we add these keys as we traverse SUM in the next loop 
        }
        int max = 0;
        
        // what if there sum[i] - K = 0 that means we found the SUM starting from 0-i
        // in this case we can add dummy entry  OR we have to have an extra condition in loop sums[i]-k == 0
        // map.put(0,-1);
        
        for(int i=0;i<sums.length;i++){
            
            if(sums[i]-k == 0) {
                max = Math.max(max,i+1);
                
            } else if(map.containsKey(sums[i]-k)){
                // we found the j
                max = Math.max(max,i-map.get(sums[i]-k));
            }
            
            if(!map.containsKey(sums[i])){  // if the key is duplicate we want the left most i so we dont override 
                map.put(sums[i],i);
            }
        }
        return max;
    }
}
