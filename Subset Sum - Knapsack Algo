Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets
such that the sum of elements in both subsets is equal.

Input: [1, 5, 11, 5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].

Input: [1, 2, 3, 5]
Output: false

Input: [1, 2, 3, 5,1]
Output: true

class Solution {    
    // WRONG SOLUTION : idea was pretty good 
    // totalSum of all n numbers should be even otherwise it wont be possible 
    // then you have to find totalSum/2 
    // So left and right pointer if the sum is less you move left pointer and minus 
    // if the sum is greater then right pointer move and add it to sum untill we find the totalSum/2
    // HERE IS CODE but it is WRONG 
    // for input like [1,2,2,3,4] it is gonna return false as there is no continuous window for target sum 6
    // we need 1+2+3 = 2+4 .... SO THIS Algorithm looks promissing for normal test cases 
    public boolean canPartition1(int[] nums) {
        Arrays.sort(nums);
        int totalSum =0;
        for(int i=0;i<nums.length;i++){
            totalSum += nums[i];
        }
        if(totalSum%2 != 0) return false; 
        int sumToFind = totalSum/2;
        System.out.println("sumToFind " + sumToFind);
        int sum =0, left=0, right =0;
        while(left<right && left < nums.length && right < nums.length){
            if(sum<sumToFind){
                sum += nums[right];
                right++;
            } else {
                sum -= nums[left];
                left++;
            }
            if(sum==sumToFind) return true;
        }
        return false;
    }
    
    // The idea reamins same totalSum should be even and we should find sumToFind = totalSum/2 
    // But how do we build a path to sumToFind that is the real question 
    // take new array as dp[0,1,2,.....sumToFind].. obviously we can mark the numbers we have in the nums as true. 
    // but then we have to mark the numbers that are generated by additing each number to nums[i]  but if we do that by N^2 then we lost the path to sum..
    // we dont know what numbers to take to lead to SUM OR traverse from(back) i.e SUM to 0
    // in the end we dont need the path but we wanna make sure we take one number at a time and dont duplicate 
    // so N^2 is not how we do it. The loop is N*sumToFind
    // See the code below how we did this by using DP. This is also 0/1 knapsack algo.
    public boolean canPartition(int[] nums) {
        int totalSum =0;
        for(int i=0;i<nums.length;i++){
            totalSum += nums[i];
        }
        if(totalSum%2 != 0) return false; 
        int sumToFind = totalSum/2;
        boolean []dp = new boolean[sumToFind+1];
        Arrays.fill(dp,false);
        dp[0] = true;
        for(int number : nums){
            for(int i=sumToFind;i>=number;i--){
                dp[i] = dp[i] || dp[i-number];
            }
        }
        // eventually we would frind path from sumToFind to 0
        return dp[sumToFind];
    }
    
    
}
