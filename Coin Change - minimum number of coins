class Solution {
    // https://www.youtube.com/watch?v=Kf_M7RdHr1M&feature=youtu.be
    public int coinChange(int[] coins, int amount) {
        if(coins.length == 0 || amount < 0) return -1;
        if(amount == 0 ) return 0;
        Map<Integer,Integer> map = new HashMap<>();
        int a=minimumCoinTopDown( amount, coins, map);
        return a==Integer.MAX_VALUE ? -1: a;
    }
    public int minimumCoinTopDown(int total, int coins[], Map<Integer, Integer> map) {
        //if total is 0 then there is nothing to do. return 0.
        if ( total == 0 ) {
            return 0;
        }
        //if map contains the result means we calculated it before. Lets return that value.
        if ( map.containsKey(total) ) {
            return map.get(total);
        }
        //iterate through all coins and see which one gives best result.
        int min = Integer.MAX_VALUE;
        for ( int i=0; i < coins.length; i++ ) {
            //if value of coin is greater than total we are looking for just continue.
            if( coins[i] > total ) {
                continue;
            }
            //recurse with total - coins[i] as new total
            int val = minimumCoinTopDown(total - coins[i], coins, map);

            //if val we get from picking coins[i] as first coin for current total is less
            // than value found so far make it minimum.
            if( val < min ) {
                min = val;
            }
        }
        //if min is MAX_VAL dont change it. Just result it as is. Otherwise add 1 to it.
        min =  (min == Integer.MAX_VALUE ? Integer.MAX_VALUE : min+1 );
        //memoize the minimum for current total.
        map.put(total, min);
        return min;
    }
}
