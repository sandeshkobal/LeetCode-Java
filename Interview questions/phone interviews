    
Karat - Josh for Roblox : 
  1 Give the N list of [parent,child] (this forms a graph).... return root nodes. 
  2 With that same list now given 2 nodes as input check if they have common ancestor. return true/false 
  
Amazon Neeraj Elastic Search : 
  15 min talk about my background. 
  Then givent Dictionary ["time","some","thing","something", "goodtime", "good", "luck"]
  and a string "goodtimeluckgoodsomething", return the list of split strings with minimum number of splits 
  if you can't split it return empty list.
  Ans : ["goodtime","luck","good","something"] 
  Wrong Ans : ["good","time","luck","good","some","thing"]
  https://leetcode.com/problems/word-break-ii/
  
  
Uber : 
    https://leetcode.com/problems/reconstruct-itinerary/
    Building itenary - Starting point is not given, and wanted longest itinery. 
    So you have to find the stating point. 
    First no duplicated and no cycle only single destination. 
    Then fligh can have multiple estinations has multiple destinations and all. 
    Everything had to run.
    
DropBOX : 
    https://leetcode.com/problems/find-duplicate-file-in-system/
    Code was not supposed to run/compile but it was writting whole code and making sure that i would run. 
    Imagine you are given a real file system, how will you search files? 
    I had to ask for different api like listFiles(), openFile(), isDirectory(), SHA256(), 
    
    If the file content is very large (GB level), how will you modify your solution? ofcourse you can build a map 
    on size of the files those are first candidates that could be the same but unique file sizes are eliminated. 
    
Turo :
    A lot of behavioural and past expirences. 
    Then binary horizontal traversal. 
    SQL queries : inner join simple and then group by having count(*) >3
    Talk about what happend when you go to some site what happens. 
        https://www.youtube.com/watch?v=T4Df5_cojAs
        How the certificated are issues and all. 
        Your browser or OS comes with preinstalled certificates. 
        The first criteria is easy to check. Your browser has a pre-installed list of trusted SSL certificates from 
        Certificate Authorities (CAs) that you can view, add and remove from. These certificates are controlled by 
        a centralised group of (in theory, and generally in practice) extremely secure, 
        reliable and trustworthy organisations like Symantec, Comodo and GoDaddy. 
        If a server presents a certificate from that list then you know you can trust them.
        A somewhat smart client might then go and ask Symantec “I’ve got a Microsoft here who say that you trust them,
        is this true?” But even if Symantec say “yep, we know them, Microsoft are legit”, you still don’t know whether
        the server claiming to be Microsoft actually is Microsoft or something much worse. 
        This is where digital signatures come in.
        As already noted, SSL certificates have an associated public/private key pair. 
        The public key is distributed as part of the certificate, 
        and the private key is kept incredibly safely guarded. This pair of asymmetric keys is used in the SSL handshake 
        to exchange a further key for both parties to symmetrically encrypt and decrypt data.    
    HTTP header
    HTTP 2.0 the steaming and pipelining 
