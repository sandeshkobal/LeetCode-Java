Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

Example 1:
Input: n = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.

Example 2:
Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.

class Solution {
    //  n*s where s is numbers of perfect squares we gonna consider 
    // This is kind of Subset problem where we say yes there are elements  = SUM/2 ( all positive numebers)
    // In subet we return only true/false but we don not consider minimum elements to find that out. Here question asks minimum number of
    // elements that leads to SUM. 
    // So we have to keep finding that SUM and then keep track how many elements we used and track minimum. 
    // SO as it looks like subset sum .. it is gonna be m*SUM loop with DP ... no it is going to be SUM*m .. bcz we can use each number many times. 
    // take new array as dp[0,1,2,.....sumToFind].. obviously we can mark the numbers we have in the nums as true. 
    // but then we have to mark the numbers that are generated by additing each number to nums[i]+nums[j] but if we do that by N^2 then we lost the path to sum..
    // we dont know what numbers to take to lead to SUM 
    
    // also if you see subset sum problem we can use number only once hence the loop is num*Sum 
    // here we can user numbers multiple times hence the loop is SUM*n
    // This is NP complete as there no polynimial time soltution and the complexity depends on the SUM number (actual data and not the data set) 
    public int numSquares(int SUM) {
        if(SUM<=0) return 0;
        
        // Build all perfect square numbers we need to consider 
        int nums[] = new int[(int) Math.sqrt(SUM) +1];
        for(int i=1;i<=nums.length;i++) {
            nums[i-1] = i*i;
            if(nums[i-1] == SUM)
                return 1;
        }
        
        int []solDP= new int[SUM+1];
        solDP[0] = 0;
        for(int total=1;total<=SUM;total++){   //  for 1-SUM build the DP array and for the SUM we have all the infor we required 
            int min = Integer.MAX_VALUE;
            for(int num : nums){
                if(total < num)
                    break; // no need process larger numbers 
                min = Math.min(min,solDP[total-num] +1);
            }
            solDP[total] = min;
        }
        return solDP[SUM];
    }
}
